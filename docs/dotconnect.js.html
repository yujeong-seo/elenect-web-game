<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>dotconnect.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="DotConnect.html">DotConnect</a><ul class='methods'><li data-type='method'><a href="DotConnect.html#.add_random_block">add_random_block</a></li><li data-type='method'><a href="DotConnect.html#.connected_dots">connected_dots</a></li><li data-type='method'><a href="DotConnect.html#.empty_adjacent">empty_adjacent</a></li><li data-type='method'><a href="DotConnect.html#.fill_board">fill_board</a></li><li data-type='method'><a href="DotConnect.html#.game_stat">game_stat</a></li><li data-type='method'><a href="DotConnect.html#.initial_board">initial_board</a></li><li data-type='method'><a href="DotConnect.html#.is_ended">is_ended</a></li><li data-type='method'><a href="DotConnect.html#.swap_turn">swap_turn</a></li></ul></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">dotconnect.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import R from "./ramda.js";

/**
 * 'dotconnect.js' is a module to model and play Dot Connect and related games. &lt;br>
 * Dot Connect is a game where user connects dots to make the longest line as possible. &lt;br>
 * In this web app, it is implemented as two player and grid-based connection game.
 * @namespace DotConnect
 * @author Yujeong Seo
 * @version 2022/23
 */
const DotConnect = Object.create(null);

/**
 * A Board is an 10x15 rectangular grid that tokens can be placed into
 * one at a time. &lt;br>
 * Tokens can be placed in any empty positions by user selection.
 * @memberof DotConnect
 * @typedef {Array.&lt;Array.&lt;number>>} board
 */

/**
 * A turn indicates the current player's turn. &lt;br>
 * Turn 0 indicates player A (fire), and
 * turn 1 indicates player B (water).
 * @memberof DotConnect
 * @typedef {(0|1)} turn
 */

/**
 * An array 'tokens' stores the type of tokens that
 * could be placed on the game board grid.
 * @memberof DotConnect
 * @typedef {Array}
 */
DotConnect.tokens = ["a_token", "b_token"];

/**
 * An object 'prev_positions' stores the grid positions of
 * the previous token. &lt;br> The keys are the turn of the players
 * and corresponding values stores that player's previous token position.
 * @memberof DotConnect
 * @typedef {Object.&lt;string, number[]>}
*/
DotConnect.prev_positions = {
    "0": [0, 0],
    "1": [0, 0]
};

/**
 * An object 'curr_positions' stores the grid positions of
 * the most current token. &lt;br> The keys are the turn of the players
 * and corresponding values stores that player's current token position.
 * @memberof DotConnect
 * @typedef {Object.&lt;string, number[]>}
*/
DotConnect.curr_positions = {
    "0": [0, 0],
    "1": [0, 0]
};

/**
 * Creates a new empty board with desired rows and columns. &lt;br>
 * Can be specified with rows and columns input.
 * Unless there is specified value, returns a 10x15 board.
 * @memberof DotConnect
 * @function
 * @param {number} [row = 15] The row (height) of the new board.
 * @param {number} [column = 10] The column (width) of the new board.
 * @returns {DotConnect.board} An empty board for starting the game.
 */
DotConnect.initial_board = function (row = 15, col = 10) {
    return new Array(row).fill().map(
        () => new Array(col).fill("")
    );
};

/**
 * Changes the turn of the player and
 * return which player is next to play.
 * @memberof DotConnect
 * @function
 * @param {DotConnect.turn} turn The current player.
 * @returns {(0|1)} The next player to play.
 */
DotConnect.swap_turn = function (turn) {
    turn = (
        turn === 0
        ? 1 // if it was "a" change to "b"
        : 0 // if token is not "a" change to "b"
    );
    return turn;
};

/**
 * As the token is placed onto the grid, it fills
 * the board with the corresponding string identifier ("a" or "b"). &lt;br>
 * Helps identifying which cell is filled with which player's token or empty.
 * @memberof DotConnect
 * @function
 * @param {DotConnect.board} board The board to add identifier.
 * @param {DotConnect.turn} turn The current player.
 * @returns {void} Adds identifier, returns nothing.
 */
DotConnect.fill_board = function (board, turn) {
    const row = DotConnect.curr_positions[turn][0];
    const col = DotConnect.curr_positions[turn][1];
    board[row][col] = (
        turn === 0
        ? "a"
        : "b"
    );
};

/**
 * Creates a random interrupting blocks on the board. &lt;br>
 * Users can not make a move to the grid identified as a block.
 * @memberof DotConnect
 * @function
 * @param {DotConnect.board} board The board to add the block.
 * @returns {void} Adds identifier, returns nothing. 
 */
DotConnect.add_random_block = function (board) {
    R.range(0,6).forEach(function (i) {
        let row = random_int(0,14);
        let col = random_int(0,9);
        board[row][col] = "x";
    });
};

const random_int = function (min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
};

/**
 * Returns the array of positions that player
 * can place their next tokens. &lt;br>
 * The positions are empty (no tokens placed)
 * and is adjacent to the most recent token that the player has placed.
 * @memberof DotConnect
 * @function
 * @param {DotConnect.board} board The board to analyse.
 * @param {DotConnect.turn} turn The current player.
 * @returns {Array.&lt;Array.&lt;number>>} An array of positions on board grid.
 */
DotConnect.empty_adjacent = function (board, turn) {
    const row = DotConnect.curr_positions[turn][0];
    const col = DotConnect.curr_positions[turn][1];
    let output = [];

    if (row &lt; 14) {
        output.push([row + 1, col]);
    }
    if (row > 0) {
        output.push([row - 1, col]);
    }
    if (col &lt; 9) {
        output.push([row, col + 1]);
    }
    if (col > 0) {
        output.push([row, col - 1]);
    }

    output = output.filter((item) => board[item[0]][item[1]] === "");
    return output;
};

/**
 * Returns the numbers of total connected dots of both player.
 * @memberof DotConnect
 * @function
 * @param {DotConnect.board} board The board to count.
 * @returns {Array.&lt;number>} An array of number of connected dots.
 */
DotConnect.connected_dots = function (board) {
    let a_count = 0;
    let b_count = 0;
    board.forEach(function (row) {
        row.forEach(function (item) {
            if (item === "a") {
                a_count += 1;
            } else if (item === "b") {
                b_count += 1;
            }
        });
    });
    return [a_count, b_count];
};

/**
 * If the game is ended, either returns the string of the
 * winner ("a" or "b") or "tie" after checking the conditions.
 * If not ended, returns undefined. &lt;br>
 * Uses {@link DotConnect.empty_adjacent} and {@link DotConnect.connected_dots}
 * to check the status and if any more legal moves can be made.
 * @memberof DotConnect
 * @function
 * @param {DotConnect.board} board The board to analyse.
 * @returns {string|undefined} A result of the game.
 */
DotConnect.is_ended = function (board) {
    const a_blocked = no_legal_moves(board, 0);
    const b_blocked = no_legal_moves(board, 1);
    const no_winner = no_free_cells(board);
    const connects = DotConnect.connected_dots(board);
    let output;

    if (connects[0] === connects[1]) {
        if (a_blocked &amp;&amp; b_blocked) {
            output = "tie";
        } else if (a_blocked &amp;&amp; !b_blocked) {
            output = "b";
        } else if (!a_blocked &amp;&amp; b_blocked) {
            output = "a";
        }
    } else if ((connects[0] > connects[1]) &amp;&amp; b_blocked) {
        output = "a";
    } else if ((connects[0] &lt; connects[1]) &amp;&amp; a_blocked) {
        output = "b";
    } else if (!no_winner) {
        output = "tie";
    } else {
        output = undefined;
    }

    return output;
};

const no_legal_moves = function (board, turn) {
    const adjacent = DotConnect.empty_adjacent(board, turn);
    if (adjacent.length === 0) {
        return true;
    }
    return false;
};

const no_free_cells = function (board) {
    let free_cells = false;
    board.forEach(function (row) {
        row.forEach(function (cell) {
            if (cell === "") {
                free_cells = true;
            }
        });
    });
    return free_cells;
};

/**
 * Returns the total win, tie, and lose of the players.
 * @memberof DotConnect
 * @function
 * @param {DotConnect.board} board The board to analyse.
 * @returns {Array.&lt;number>} An array with the number of results.
 */
DotConnect.game_stat = function (board) {
    const result = DotConnect.is_ended(board);
    if (result === "a") {
        a_win += 1;
    } else if (result === "b") {
        b_win += 1;
    } else if (result === "tie") {
        tie += 1;
    }
    return [a_win, tie, b_win];
};

let a_win = 0;
let tie = 0;
let b_win = 0;

export default Object.freeze(DotConnect);</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.2</a> on Thu Jun 22 2023 21:48:27 GMT+0900 (Korean Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
